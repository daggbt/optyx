---
title: "Benchmarks"
description: "Performance analysis and comparison with SciPy"
---

# Benchmarks

Optyx includes a comprehensive benchmark suite measuring **end-to-end performance** including variable creation, problem setup, constraint construction, and solving. All benchmarks compare against raw SciPy (which has no build phase).

## Quick Start

```bash
# Run all benchmark tests
uv run pytest benchmarks/ -v

# Generate performance analysis plots
uv run python benchmarks/run_benchmarks.py

# Copy plots to docs (for documentation updates)
cp benchmarks/results/*.png docs/assets/benchmarks/
```

::: {.callout-note}
## What We Measure
All benchmarks measure **total time** including:

- Variable creation
- Problem setup  
- Constraint construction
- Cold solve (first solve, includes compilation)
- Warm solve (cached subsequent solves)
:::

## Performance Summary

| Problem Type | Size | Cold Overhead | Warm Overhead | Notes |
|--------------|------|---------------|---------------|-------|
| **LP** | n=50 | 1.8x | 1.2x | Near-parity with SciPy linprog |
| **LP** | n=500 | 2.4x | 1.1x | Warm solves near-parity |
| **LP** | n=2000 | 2.1x | 1.4x | Scales to large problems |
| **NLP** | n=50 | 7.9x | 1.7x | Autodiff compilation cost |
| **NLP** | n=500 | 9.4x | **0.2x** | Warm solves 5x faster than SciPy |
| **CQP** | n=50 | 32.5x | 2.9x | Constrained problems (SLSQP) |
| **CQP** | n=500 | 96.6x | 6.2x | Jacobian compilation overhead |

**Key Insight**: Cold solves include one-time compilation. Warm solves (repeated optimization with cached structure) achieve near-parity or better than raw SciPy.

---

## LP Scaling: VectorVariable vs Loop-Based

![LP Scaling Comparison](assets/benchmarks/lp_scaling_comparison.png){width=100%}

### Loop-Based Variables (n ≤ 100)

| n | Build | Cold Solve | Warm Solve | SciPy | Cold Overhead | Warm Overhead |
|---|-------|------------|------------|-------|---------------|---------------|
| 10 | 0.2ms | 6.7ms | 1.4ms | 1.1ms | 6.5x | 1.5x |
| 25 | 0.6ms | 30.2ms | 1.3ms | 1.2ms | 25.5x | 1.6x |
| 50 | 2.8ms | 228.5ms | 2.6ms | 2.4ms | 95.4x | 2.2x |
| 100 | 15.3ms | 2,336ms | 3.2ms | 3.0ms | 774x | 6.1x |

::: {.callout-warning}
## Loop-Based Variables Don't Scale
Loop-based variable construction creates O(n²) expression tree nodes, causing exponential compilation time. Use VectorVariable for n > 50.
:::

### VectorVariable (n ≤ 2,000)

| n | Build | Cold Solve | Warm Solve | SciPy | Cold Overhead | Warm Overhead |
|---|-------|------------|------------|-------|---------------|---------------|
| 10 | 0.1ms | 1.3ms | 1.1ms | 1.3ms | 1.1x | 1.0x |
| 25 | 0.1ms | 1.7ms | 1.6ms | 2.3ms | 0.8x | **0.7x** |
| 50 | 0.3ms | 4.3ms | 2.6ms | 2.5ms | 1.8x | 1.2x |
| 100 | 0.5ms | 10.9ms | 4.7ms | 6.4ms | 1.8x | **0.8x** |
| 500 | 1.4ms | 124ms | 55.6ms | 53.1ms | 2.4x | 1.1x |
| 1000 | 6.1ms | 478ms | 244ms | 247ms | 2.0x | **1.0x** |
| 2000 | 5.7ms | 2,203ms | 1,457ms | 1,076ms | 2.1x | 1.4x |

**VectorVariable achieves near-parity with raw SciPy** for warm solves at all scales. Cold solve overhead is ~2x due to one-time compilation.

---

## NLP Scaling: Unconstrained Optimization

![NLP Scaling Comparison](assets/benchmarks/nlp_scaling_comparison.png){width=100%}

Objective: `min Σx²ᵢ - Σxᵢ` (optimal at x* = 0.5)

### VectorVariable with `x @ x - x.sum()`

| n | Build | Cold Solve | Warm Solve | SciPy | Cold Overhead | Warm Overhead |
|---|-------|------------|------------|-------|---------------|---------------|
| 10 | 0.1ms | 1.2ms | 0.5ms | 0.6ms | 2.3x | 0.9x |
| 25 | 0.0ms | 2.5ms | 0.6ms | 0.6ms | 4.7x | 1.2x |
| 50 | 0.1ms | 4.8ms | 1.0ms | 0.6ms | 7.9x | 1.7x |
| 100 | 0.1ms | 45.7ms | 1.1ms | 0.9ms | 52.6x | 1.4x |
| 500 | 0.5ms | 138ms | 3.1ms | 14.8ms | 9.4x | **0.2x** |
| 1000 | 1.1ms | 545ms | 6.9ms | 102ms | 5.4x | **0.1x** |
| 2000 | 2.1ms | 1,435ms | 14.2ms | 1,576ms | **0.9x** | **0.01x** |

::: {.callout-tip}
## At Large Scale, Optyx Can Be Faster
At n=2000, Optyx warm solves are **100x faster** than SciPy due to cached gradient computation and efficient vectorized evaluation.
:::

---

## Constrained QP Scaling

![CQP Scaling Comparison](assets/benchmarks/cqp_scaling_comparison.png){width=100%}

Objective: `min Σx²ᵢ` subject to `Σxᵢ ≥ 1, xᵢ ≥ 0`

### VectorVariable with `x @ x`, `x.sum()`

| n | Build | Cold Solve | Warm Solve | SciPy | Cold Overhead | Warm Overhead |
|---|-------|------------|------------|-------|---------------|---------------|
| 10 | 0.1ms | 2.1ms | 0.4ms | 0.2ms | 12.4x | 2.6x |
| 25 | 0.1ms | 4.4ms | 1.3ms | 0.3ms | 16.7x | 5.2x |
| 50 | 0.1ms | 9.0ms | 0.7ms | 0.3ms | 32.5x | 2.9x |
| 100 | 0.1ms | 17.5ms | 1.1ms | 0.4ms | 50.2x | 3.5x |
| 500 | 0.5ms | 200ms | 12.4ms | 2.1ms | 96.6x | 6.2x |
| 1000 | 1.1ms | 475ms | 92.3ms | 10.3ms | 46.4x | 9.1x |
| 2000 | 2.3ms | 1,842ms | 562ms | 40.9ms | 45.1x | 13.8x |

Constrained problems have higher overhead due to Jacobian compilation for constraint gradients.

---

## Overhead Summary by Problem Type

![Overhead Breakdown](assets/benchmarks/overhead_breakdown.png){width=100%}

| Problem Type | Cold Overhead | Warm Overhead |
|--------------|---------------|---------------|
| LP (n=50) | 2.0x | 1.4x |
| LP (n=500) | 2.4x | 1.1x |
| NLP (n=50) | 14.4x | 2.3x |
| NLP (n=500) | 6.7x | **0.3x** |
| CQP (n=50) | 36.8x | 3.6x |
| CQP (n=500) | 117.2x | 6.2x |

**Pattern**: Cold overhead is high due to compilation, but warm overhead approaches 1x for LP/NLP and remains manageable for constrained problems.

---

## When to Use Optyx

### Ideal Use Cases

✅ **Parameter sweeps**: Solve similar problems with different parameters  
✅ **Real-time optimization**: Repeated solves with cached structure  
✅ **Prototyping**: Clean Python API, no manual gradients  
✅ **Large LP**: VectorVariable achieves parity with SciPy  
✅ **Non-convex NLP**: Automatic differentiation with exact gradients

### Consider Alternatives For

⚠️ **One-shot constrained QP**: High cold-solve overhead  
⚠️ **Large dense quadratic forms (n>50)**: CVXPY's specialized QP solvers scale better  
⚠️ **Loop-based variables at scale**: Use VectorVariable instead

---

## Comparison with CVXPY

For convex problems, Optyx can be compared against CVXPY. Install with `uv sync --extra benchmarks`.

| Problem | Optyx | CVXPY | Overhead | Notes |
|---------|-------|-------|----------|-------|
| Small LP (2 vars) | 1.1ms | 1.0ms | 1.08x | Near parity |
| Medium LP (20 vars) | 1.3ms | 1.5ms | **0.85x** | Optyx faster |
| Simple QP | 0.4ms | 1.2ms | **0.33x** | Optyx 3x faster |
| Portfolio QP (n=10) | 3.6ms | 2.5ms | 1.47x | CVXPY's specialized QP solver |
| Portfolio QP (n=50) | 17.6ms | 1.7ms | 10.1x | CVXPY scales better for large QP |

::: {.callout-note}
## Optyx vs CVXPY: Different Strengths
- **LP/Simple QP**: Optyx matches or beats CVXPY
- **Dense Quadratic Programs**: CVXPY's specialized `quad_form` with interior-point solvers scales better for large portfolio optimization
- **Non-convex NLP**: Optyx supports non-convex objectives with autodiff; CVXPY requires convexity
:::

---

## Running Benchmarks

```bash
# All benchmarks
uv run pytest benchmarks/ -v

# By category
uv run pytest benchmarks/validation/ -v
uv run pytest benchmarks/performance/ -v
uv run pytest benchmarks/accuracy/ -v
uv run pytest benchmarks/comparison/ -v

# Generate plots
uv run python benchmarks/run_benchmarks.py
```

## Success Criteria

| Criterion | Target | Status |
|-----------|--------|--------|
| LP warm overhead | < 1.5x vs SciPy | ✅ ~1.0x |
| NLP warm overhead | < 3x vs SciPy | ✅ ~1.1-1.3x |
| VectorVariable scales | n > 1000 | ✅ n=2000 tested |
| Gradient accuracy | < 1e-5 error | ✅ < 1e-10 |
| All validations pass | 100% | ✅ 100% |
