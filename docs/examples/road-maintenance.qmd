---
title: "Road Maintenance Optimization"
description: "Budget allocation for road infrastructure with non-linear deterioration models"
execute:
  warning: false
---

## Problem Statement

An infrastructure asset manager needs to allocate a limited maintenance budget across a network of road segments to:

- **Maximize user satisfaction** weighted by traffic volume
- Account for **non-linear repair effectiveness** (diminishing returns)
- Model **user satisfaction** as a sigmoid function of road condition

This example demonstrates Optyx's ability to handle complex nested non-linearities where manual gradient calculation would be tedious and error-prone.

---

## Mathematical Formulation

Given:
- $B_i$ = budget allocated to road $i$
- $PCI_i$ = current Pavement Condition Index (0-100)
- $d_i$ = annual decay rate
- $T_i$ = daily traffic volume

**Repair Model (Diminishing Returns):**

$$
\text{Gain}(B) = 40 \cdot (1 - e^{-0.5 \cdot B})
$$

**Satisfaction Model (S-curve):**

$$
S(PCI) = \frac{100}{1 + e^{-0.12 \cdot (PCI - 50)}}
$$

**Objective:**

$$
\max \sum_i T_i \cdot S\left(PCI_i - d_i + \text{Gain}(B_i)\right)
$$

**Subject to:**

$$
\sum_i B_i \leq B_{total}
$$

---

## Why Auto-Diff Matters Here

The derivative of the objective with respect to budget $B_i$ requires the **chain rule** through both the sigmoid and exponential:

$$
\frac{\partial U}{\partial B_i} = T_i \cdot S'(\cdot) \cdot \frac{\partial}{\partial B_i}\left[40(1 - e^{-0.5 B_i})\right]
$$

Expanding this manually is tedious. Optyx computes it **symbolically and exactly**.

---

## Implementation

```{python}
import numpy as np
from optyx import Variable, Problem, exp
from optyx.core.compiler import compile_gradient

# Road network data
roads = ["Hwy 101", "Route 66", "I-95", "Main St", "Broadway"]
traffic = [50000, 12000, 85000, 5000, 15000]  # Daily vehicles
current_pci = [45, 60, 35, 70, 55]           # Current condition
decay_rate = [5, 3, 8, 2, 4]                 # Annual deterioration

total_budget = 10.0  # $10M available
max_per_road = 5.0   # Max $5M per road

print("Road Network Status:")
print("-" * 50)
for i, road in enumerate(roads):
    print(f"{road:<12} Traffic: {traffic[i]:>6,}  PCI: {current_pci[i]:>3}  Decay: {decay_rate[i]}")
```

---

## Building the Non-Linear Model

```{python}
# Decision variables
road_ids = ["hwy101", "route66", "i95", "main_st", "broadway"]
budget_vars = [Variable(f"budget_{rid}", lb=0.0, ub=max_per_road) for rid in road_ids]

# Non-linear models as optyx expressions
def repair_model(spend):
    """Diminishing returns: Gain = 40 * (1 - exp(-0.5 * spend))"""
    return 40.0 * (1 - exp(-0.5 * spend))

def satisfaction_model(pci):
    """S-curve: S = 100 / (1 + exp(-0.12 * (pci - 50)))"""
    return 100.0 / (1 + exp(-0.12 * (pci - 50)))

# Build objective: maximize total weighted satisfaction
total_utility = 0
for i in range(len(roads)):
    future_pci = current_pci[i] - decay_rate[i] + repair_model(budget_vars[i])
    user_sat = satisfaction_model(future_pci)
    total_utility += traffic[i] * user_sat

print("✓ Symbolic model built with nested exp() and sigmoid functions")
```

---

## Inspecting the Automatic Gradient

```{python}
# Compile the gradient function
grad_fn = compile_gradient(total_utility, budget_vars)

# Evaluate at uniform $1M allocation
test_point = np.array([1.0, 1.0, 1.0, 1.0, 1.0])
grad_values = grad_fn(test_point)

print("Marginal Utility at $1M uniform allocation:")
print("-" * 45)
for i, road in enumerate(roads):
    print(f"∂U/∂{road:<10}: {grad_values[i]:>12,.0f}")
print("-" * 45)
print("Higher gradient = more value from additional spending")
```

The gradient shows **I-95** has 25× higher marginal utility than **Main St** — the optimizer should allocate accordingly.

---

## Solving the Problem

```{python}
# Add penalty for unspent budget (encourages full allocation)
budget_sum = budget_vars[0]
for v in budget_vars[1:]:
    budget_sum = budget_sum + v

penalty = 1e6 * (budget_sum - total_budget) ** 2
penalized_utility = total_utility - penalty

# Create and solve problem
prob = Problem().maximize(penalized_utility)
prob.subject_to(budget_sum <= total_budget)

sol = prob.solve()

print(f"Solver status: {sol.status.value}")
print(f"Solve time: {sol.solve_time*1000:.1f} ms")
```

---

## Results

```{python}
print("\nOptimal Budget Allocation:")
print("-" * 70)
print(f"{'Road':<12} {'Traffic':>10} {'Old PCI':>10} {'Budget':>10} {'New PCI':>10} {'Satisf%':>10}")
print("-" * 70)

total_spent = 0
for i, road in enumerate(roads):
    spend = sol[budget_vars[i]]
    total_spent += spend
    
    pci_gain = 40.0 * (1 - np.exp(-0.5 * spend))
    final_pci = current_pci[i] - decay_rate[i] + pci_gain
    sat = 100.0 / (1 + np.exp(-0.12 * (final_pci - 50)))
    
    print(f"{road:<12} {traffic[i]:>10,} {current_pci[i]:>10} ${spend:>9.2f} {final_pci:>10.1f} {sat:>10.1f}")

print("-" * 70)
print(f"Total Spent: ${total_spent:.2f}M / ${total_budget:.2f}M")
```

---

## Key Insights

The optimal solution shows:

1. **I-95 gets the maximum** ($5M) — highest traffic volume
2. **Hwy 101 gets significant funding** — high traffic and improvable condition
3. **Main St gets $0** — already in good condition (diminishing returns on S-curve)
4. **Route 66 and Broadway** get modest allocations

This matches the gradient predictions perfectly. The optimizer uses the **exact symbolic derivatives** computed by Optyx to navigate the complex objective landscape efficiently.

---

## Extensions

This model can be extended with:

- **Multi-year planning horizons**
- **Different repair action types** (patching vs. resurfacing vs. reconstruction)
- **Stochastic deterioration models**
- **Network connectivity weights** (critical routes)
- **Equity constraints** (minimum service levels for all roads)
