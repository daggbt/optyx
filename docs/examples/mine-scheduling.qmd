---
title: "Mine Production Scheduling"
description: "Multi-period open-pit mine scheduling with NPV maximization"
date: last-modified
---

## Overview

This example demonstrates a **multi-period mine production scheduling** problem—a core optimization challenge in open-pit mining operations. We'll maximize the Net Present Value (NPV) of extracted ore while respecting:

- Processing plant capacity limits
- Mining equipment capacity limits
- Grade blending constraints (min/max ore grade)
- Precedence constraints (can't mine lower blocks before upper blocks)

This is directly relevant to mining operations at companies like BHP, Fortescue, and Rio Tinto.

## Problem Setup

Consider a simplified open-pit mine with 9 blocks arranged in a cross-section:

```
   [0] [1] [2]    ← Level 0 (surface)
     [3] [4]      ← Level 1 (must mine 0,1 or 1,2 first)
       [5]        ← Level 2 (must mine 3,4 first)
   [6] [7] [8]    ← Level 0 (surface, separate area)
```

Each block has properties: tonnage, copper grade, and mining cost.

```{python}
import numpy as np
from optyx import Variable, Problem

# Time periods (years)
n_periods = 4
discount_rate = 0.10  # 10% annual discount rate

# Mining blocks
n_blocks = 9

# Block properties
block_tonnage = np.array([100, 120, 110, 80, 90, 60, 95, 105, 100])  # kt
block_grade = np.array([0.8, 1.2, 0.9, 1.5, 2.0, 2.5, 0.7, 1.1, 0.85])  # % Cu
block_mining_cost = np.array([3.5, 3.8, 3.6, 4.2, 4.5, 5.0, 3.4, 3.7, 3.5])  # $/t

# Economic parameters
copper_price = 8000  # $/tonne Cu
processing_cost = 15  # $/t ore
recovery_rate = 0.90  # 90% Cu recovery

# Capacity constraints
max_mining_capacity = 250  # kt/period
max_processing_capacity = 200  # kt/period
min_blend_grade = 1.0  # Minimum average grade (% Cu)
max_blend_grade = 2.0  # Maximum average grade (% Cu)

# Precedence: block i must be mined before block j
precedence = [
    (0, 3), (1, 3),  # Blocks 0,1 must precede block 3
    (1, 4), (2, 4),  # Blocks 1,2 must precede block 4
    (3, 5), (4, 5),  # Blocks 3,4 must precede block 5
]

print(f"Blocks: {n_blocks}")
print(f"Periods: {n_periods} years")
print(f"Total ore: {block_tonnage.sum():.0f} kt")
print(f"Average grade: {np.average(block_grade, weights=block_tonnage):.2f}% Cu")
```

## Decision Variables

We use continuous variables $x_{i,t} \in [0, 1]$ representing the fraction of block $i$ mined in period $t$:

```{python}
# x[i,t] = fraction of block i mined in period t
x = {}
for i in range(n_blocks):
    for t in range(n_periods):
        x[i, t] = Variable(f"x_{i}_{t}", lb=0, ub=1)

print(f"Decision variables: {len(x)} (blocks × periods)")
```

## Objective: Maximize NPV

The Net Present Value accounts for time value of money:

$$
\text{NPV} = \sum_{t=0}^{T-1} \frac{1}{(1+r)^t} \sum_{i=0}^{n-1} (\text{Revenue}_i - \text{Cost}_i) \cdot x_{i,t}
$$

where:
- Revenue = tonnage × grade × recovery × copper price
- Cost = tonnage × (mining cost + processing cost)

```{python}
npv = 0
for t in range(n_periods):
    discount_factor = 1 / (1 + discount_rate) ** t
    
    for i in range(n_blocks):
        tonnage = block_tonnage[i]
        grade = block_grade[i] / 100  # Convert to decimal
        
        # Revenue from copper ($ thousands)
        revenue = tonnage * 1000 * grade * recovery_rate * copper_price / 1000
        
        # Costs ($ thousands)
        cost = tonnage * 1000 * (block_mining_cost[i] + processing_cost) / 1000
        
        # NPV contribution
        npv = npv + (revenue - cost) * discount_factor * x[i, t]

print("NPV objective built with discounted cash flows")
```

## Constraints

### 1. Block Extraction Limits

Each block can only be mined once (total extraction ≤ 1):

$$\sum_{t=0}^{T-1} x_{i,t} \leq 1 \quad \forall i$$

### 2. Capacity Constraints

Mining and processing capacity per period:

$$\sum_{i=0}^{n-1} \text{tonnage}_i \cdot x_{i,t} \leq \text{Capacity} \quad \forall t$$

### 3. Precedence Constraints

Upper blocks must be mined before lower blocks. For each precedence pair $(i, j)$:

$$\sum_{s=0}^{t} x_{i,s} \geq \sum_{s=0}^{t} x_{j,s} \quad \forall t$$

### 4. Grade Blending Constraints

The average grade of ore processed each period must be within bounds. Linearized form:

$$\sum_i \text{tonnage}_i \cdot (\text{grade}_i - \text{min\_grade}) \cdot x_{i,t} \geq 0$$

```{python}
prob = Problem(name="mine_scheduling")
prob.maximize(npv)

# 1. Each block mined at most once
for i in range(n_blocks):
    total_extraction = sum(x[i, t] for t in range(n_periods))
    prob.subject_to(total_extraction <= 1)

# 2. Mining capacity per period
for t in range(n_periods):
    period_mining = sum(block_tonnage[i] * x[i, t] for i in range(n_blocks))
    prob.subject_to(period_mining <= max_mining_capacity)

# 3. Processing capacity per period
for t in range(n_periods):
    period_processing = sum(block_tonnage[i] * x[i, t] for i in range(n_blocks))
    prob.subject_to(period_processing <= max_processing_capacity)

# 4. Precedence constraints
for (i, j) in precedence:
    for t in range(n_periods):
        cum_i = sum(x[i, s] for s in range(t + 1))
        cum_j = sum(x[j, s] for s in range(t + 1))
        prob.subject_to(cum_i >= cum_j)

# 5. Grade blending constraints
for t in range(n_periods):
    # Minimum grade
    min_grade_expr = sum(
        block_tonnage[i] * (block_grade[i] - min_blend_grade) * x[i, t]
        for i in range(n_blocks)
    )
    prob.subject_to(min_grade_expr >= 0)
    
    # Maximum grade
    max_grade_expr = sum(
        block_tonnage[i] * (max_blend_grade - block_grade[i]) * x[i, t]
        for i in range(n_blocks)
    )
    prob.subject_to(max_grade_expr >= 0)

total_constraints = (
    n_blocks +                      # extraction limits
    n_periods * 2 +                 # capacity constraints
    len(precedence) * n_periods +   # precedence
    n_periods * 2                   # grade blending
)
print(f"Total constraints: {total_constraints}")
```

## Solve

```{python}
solution = prob.solve(method="trust-constr")

print(f"Status: {solution.status.value}")
print(f"NPV: ${solution.objective_value:,.0f} thousand")
print(f"Iterations: {solution.iterations}")
print(f"Solve time: {solution.solve_time*1000:.1f} ms")
```

## Results Analysis

### Extraction Schedule

```{python}
# Print schedule table
print(f"\n{'Block':<8}", end="")
for t in range(n_periods):
    print(f"{'Year '+str(t+1):>10}", end="")
print(f"{'Total':>10}")
print("-" * (8 + 10 * (n_periods + 1)))

total_by_period = [0] * n_periods
for i in range(n_blocks):
    print(f"Block {i:<3}", end="")
    block_total = 0
    for t in range(n_periods):
        val = solution[f"x_{i}_{t}"]
        print(f"{val:>10.2f}", end="")
        block_total += val
        total_by_period[t] += val * block_tonnage[i]
    print(f"{block_total:>10.2f}")

print("-" * (8 + 10 * (n_periods + 1)))
print(f"{'Tonnage':<8}", end="")
for t in range(n_periods):
    print(f"{total_by_period[t]:>10.0f}", end="")
print(f"{sum(total_by_period):>10.0f} kt")
```

### Grade by Period

```{python}
print(f"\n{'Period':<12} {'Tonnage (kt)':>15} {'Avg Grade (%Cu)':>18}")
print("-" * 45)

for t in range(n_periods):
    weighted_grade = sum(
        block_grade[i] * block_tonnage[i] * solution[f"x_{i}_{t}"]
        for i in range(n_blocks)
    )
    if total_by_period[t] > 0:
        avg_grade = weighted_grade / total_by_period[t]
        print(f"Year {t+1:<7} {total_by_period[t]:>15.0f} {avg_grade:>18.2f}")
    else:
        print(f"Year {t+1:<7} {0:>15.0f} {'N/A':>18}")
```

### Economic Summary

```{python}
total_tonnage = sum(total_by_period)
total_cu = sum(
    block_grade[i] / 100 * block_tonnage[i] * sum(solution[f"x_{i}_{t}"] for t in range(n_periods))
    for i in range(n_blocks)
)

print(f"\nTotal ore mined: {total_tonnage:,.0f} kt")
print(f"Total copper content: {total_cu:,.1f} kt Cu")
print(f"Average grade: {total_cu / total_tonnage * 100:.2f}% Cu")
print(f"NPV: ${solution.objective_value:,.0f} thousand")
print(f"NPV per tonne ore: ${solution.objective_value / total_tonnage:.2f}/t")
```

## Key Takeaways

1. **Indexed variables**: `x[i, t]` pattern for multi-dimensional decisions
2. **Precedence constraints**: Ensure physically feasible mining sequences
3. **Grade blending**: Linearized ratio constraints for mill feed quality
4. **NPV discounting**: Time value of money in multi-period planning
5. **Capacity planning**: Balance equipment and processing limits

## Extensions

This model can be extended with:

- **Binary variables** for discrete block extraction (MILP)
- **Stockpile management** and blending from stockpiles
- **Stochastic optimization** for price/grade uncertainty
- **Equipment scheduling** and haul route optimization
- **Environmental constraints** (dust, water, rehabilitation)
