---
title: "Portfolio Optimization"
description: "Mean-variance portfolio optimization with efficient frontier"
execute:
  warning: false
---

## Problem Statement

A quantitative analyst needs to allocate capital across multiple assets to:

- **Maximize returns** for a given risk level, or
- **Minimize risk** for a given return target

This is the classic **Markowitz mean-variance optimization** problem.

---

## Mathematical Formulation

Given:
- $\mu$ = vector of expected returns
- $\Sigma$ = covariance matrix of returns
- $w$ = portfolio weights

**Minimize variance (risk):**

$$
\min_w \quad w^T \Sigma w
$$

**Subject to:**

$$
\begin{aligned}
\mu^T w &\geq r_{target} & \text{(return target)} \\
\sum_i w_i &= 1 & \text{(fully invested)} \\
w_i &\geq 0 & \text{(no short selling)}
\end{aligned}
$$

---

## Implementation

```{python}
import numpy as np
from optyx import Variable, Problem

# Asset data
assets = ["Tech", "Energy", "Finance", "Healthcare", "Consumer", "Utilities"]
n_assets = len(assets)

# Expected annual returns
expected_returns = np.array([0.12, 0.08, 0.10, 0.09, 0.07, 0.05])

# Covariance matrix (simplified)
cov_matrix = np.array([
    [0.040, 0.010, 0.015, 0.008, 0.005, 0.002],
    [0.010, 0.035, 0.012, 0.006, 0.004, 0.003],
    [0.015, 0.012, 0.030, 0.010, 0.006, 0.004],
    [0.008, 0.006, 0.010, 0.025, 0.008, 0.005],
    [0.005, 0.004, 0.006, 0.008, 0.020, 0.006],
    [0.002, 0.003, 0.004, 0.005, 0.006, 0.015],
])

print("Asset Universe:")
for i, asset in enumerate(assets):
    print(f"  {asset}: E[r]={expected_returns[i]:.1%}, σ={np.sqrt(cov_matrix[i,i]):.1%}")
```

---

## Creating the Optimization Model

```{python}
# Decision variables: portfolio weights
weights = [Variable(asset, lb=0, ub=0.4) for asset in assets]  # Max 40% per asset

# Portfolio return: sum of weight * expected return
portfolio_return = sum(
    weights[i] * expected_returns[i] 
    for i in range(n_assets)
)

# Portfolio variance: w^T * Cov * w
portfolio_variance = sum(
    weights[i] * weights[j] * cov_matrix[i, j]
    for i in range(n_assets)
    for j in range(n_assets)
)

# Constraints
total_weight = sum(weights)

print(f"Variables: {n_assets}")
print(f"Objective: minimize portfolio variance")
```

---

## Solving for Minimum Variance Portfolio

```{python}
target_return = 0.08  # 8% target

solution = (
    Problem("min_variance")
    .minimize(portfolio_variance)
    .subject_to(total_weight >= 0.99)
    .subject_to(total_weight <= 1.01)
    .subject_to(portfolio_return >= target_return)
    .solve()
)

print("=" * 50)
print("MINIMUM VARIANCE PORTFOLIO")
print(f"Target Return: {target_return:.1%}")
print("=" * 50)
print("\nOptimal Allocation:")
for asset in assets:
    w = solution[asset]
    if w > 0.01:
        print(f"  {asset:12s}: {w:6.1%}")

actual_return = sum(solution[a] * expected_returns[i] for i, a in enumerate(assets))
actual_risk = np.sqrt(solution.objective_value)
print(f"\nPortfolio Metrics:")
print(f"  Expected Return: {actual_return:.2%}")
print(f"  Risk (std dev):  {actual_risk:.2%}")
print(f"  Sharpe Ratio:    {actual_return/actual_risk:.2f}")
```

---

## Efficient Frontier

The efficient frontier shows the best risk-return trade-offs:

```{python}
def solve_for_return_target(target):
    """Solve minimum variance portfolio for given return target."""
    w = [Variable(f"w_{i}", lb=0, ub=0.4) for i in range(n_assets)]
    
    port_ret = sum(w[i] * expected_returns[i] for i in range(n_assets))
    port_var = sum(
        w[i] * w[j] * cov_matrix[i, j]
        for i in range(n_assets) for j in range(n_assets)
    )
    total = sum(w)
    
    sol = (
        Problem()
        .minimize(port_var)
        .subject_to(total >= 0.99)
        .subject_to(total <= 1.01)
        .subject_to(port_ret >= target)
        .solve()
    )
    
    if sol.status.name == "OPTIMAL":
        return np.sqrt(sol.objective_value), target
    return None, None

# Compute frontier
targets = np.linspace(0.05, 0.11, 13)
frontier_points = []

for t in targets:
    risk, ret = solve_for_return_target(t)
    if risk is not None:
        frontier_points.append((risk, ret))

print("\nEfficient Frontier:")
print("-" * 40)
print(f"{'Return':>10} | {'Risk':>10} | {'Sharpe':>10}")
print("-" * 40)
for risk, ret in frontier_points:
    sharpe = ret / risk if risk > 0 else 0
    print(f"{ret:>10.2%} | {risk:>10.2%} | {sharpe:>10.2f}")
```

---

## Visualizing the Frontier (ASCII)

```{python}
# Simple ASCII visualization
print("\nEfficient Frontier (ASCII)")
print("Return ↑")
print("       |")

# Scale to 40 columns
risks = [p[0] for p in frontier_points]
returns = [p[1] for p in frontier_points]
min_risk, max_risk = min(risks), max(risks)

for i, (risk, ret) in enumerate(reversed(frontier_points)):
    # Map risk to column position (0-40)
    col = int((risk - min_risk) / (max_risk - min_risk + 0.001) * 40)
    line = " " * 7 + "|" + " " * col + "*"
    label = f" {ret:.1%}"
    print(line + label)

print("       |" + "-" * 45 + " Risk →")
print(f"       0    {min_risk:.1%}                        {max_risk:.1%}")
```

---

## Rebalancing on Price Shock

What if Tech drops 20%?

```{python}
# Simulate price shock
shocked_returns = expected_returns.copy()
shocked_returns[0] = 0.05  # Tech return drops

# Re-optimize
w = [Variable(f"w_{i}", lb=0, ub=0.4) for i in range(n_assets)]
port_ret = sum(w[i] * shocked_returns[i] for i in range(n_assets))
port_var = sum(
    w[i] * w[j] * cov_matrix[i, j]
    for i in range(n_assets) for j in range(n_assets)
)

solution_shocked = (
    Problem()
    .minimize(port_var)
    .subject_to(sum(w) >= 0.99)
    .subject_to(sum(w) <= 1.01)
    .subject_to(port_ret >= 0.07)  # Lower target after shock
    .solve()
)

print("\nRebalanced Portfolio (after Tech shock):")
for i, asset in enumerate(assets):
    w_old = solution[asset]
    w_new = solution_shocked[f"w_{i}"]
    if abs(w_old - w_new) > 0.01:
        print(f"  {asset:12s}: {w_old:6.1%} → {w_new:6.1%}")
```

---

## Key Takeaways

1. **Natural formulation**: The math translates directly to Optyx code
2. **Automatic gradients**: No need to derive Jacobians of the covariance term
3. **Fast re-optimization**: Rebalancing after shocks takes milliseconds
4. **Extensible**: Easy to add sector constraints, transaction costs, etc.

---

## Extensions

Try adding:
- Sector exposure limits
- Transaction costs
- Minimum holding sizes
- Cardinality constraints (max N assets)

See the [Mining Fleet Dispatch](fleet-dispatch.qmd) example for another real-world application.
