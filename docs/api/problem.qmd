---
title: "Problem API"
description: "Building and solving optimization problems"
date: last-modified
---

## Problem

The `Problem` class is the main container for optimization problems.

```python
from optyx import Problem

prob = Problem(name=None)
```

### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `name` | `str | None` | Optional problem name | `None` |

---

## Building Problems

### Fluent API

Chain methods for concise problem definition:

```{python}
from optyx import Variable, Problem

x = Variable("x", lb=0)
y = Variable("y", lb=0)

solution = (
    Problem("quadratic")
    .minimize(x**2 + y**2)
    .subject_to(x + y >= 1)
    .subject_to(x <= 5)
    .solve()
)

print(f"Objective: {solution.objective_value:.4f}")
```

### Step-by-Step

Build problems incrementally:

```{python}
from optyx import Variable, Problem

x = Variable("x", lb=0)
y = Variable("y", lb=0)

prob = Problem("step-by-step")
prob.minimize(x**2 + y**2)
prob.subject_to(x + y >= 1)
prob.subject_to(x <= 5)

solution = prob.solve()
print(f"Objective: {solution.objective_value:.4f}")
```

---

## Methods

### `.minimize(objective)`

Set a minimization objective.

```python
prob.minimize(expr)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `objective` | `Expression` | The expression to minimize |

**Returns:** `self` (for chaining)

### `.maximize(objective)`

Set a maximization objective.

```python
prob.maximize(expr)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `objective` | `Expression` | The expression to maximize |

**Returns:** `self` (for chaining)

::: {.callout-note}
Internally, maximization is converted to minimization by negating the objective.
:::

### `.subject_to(constraint)`

Add a constraint to the problem.

```python
prob.subject_to(constraint)
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `constraint` | `Constraint` | An inequality or equality constraint |

**Returns:** `self` (for chaining)

### `.solve(**kwargs)`

Solve the optimization problem.

```python
solution = prob.solve(method="SLSQP", strict=False, x0=None, tol=None, maxiter=None)
```

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `method` | `str` | Solver method | `"SLSQP"` |
| `strict` | `bool` | Raise error for unsupported features | `False` |
| `x0` | `np.ndarray | None` | Initial point | Auto-generated |
| `tol` | `float | None` | Solver tolerance | Solver default |
| `maxiter` | `int | None` | Maximum iterations | Solver default |

**Returns:** [`Solution`](solution.qmd)

**Raises:** `ValueError` if `strict=True` and the problem contains features the solver cannot handle (e.g., integer/binary variables with SciPy).

**Available methods:**

| Method | Bounds | Constraints | Gradient | Hessian | Description |
|--------|--------|-------------|----------|---------|-------------|
| `"SLSQP"` | ✅ | ✅ | ✅ | ❌ | Sequential Least Squares Programming (default) |
| `"trust-constr"` | ✅ | ✅ | ✅ | ✅ | Trust-region constrained optimization |
| `"L-BFGS-B"` | ✅ | ❌ | ✅ | ❌ | Limited-memory BFGS with bounds |
| `"COBYLA"` | ❌ | ✅ (ineq) | ❌ | ❌ | Constrained Optimization BY Linear Approx |
| `"TNC"` | ✅ | ❌ | ✅ | ❌ | Truncated Newton Conjugate-Gradient |
| `"Powell"` | ✅ | ❌ | ❌ | ❌ | Powell's conjugate direction method |
| `"Nelder-Mead"` | ✅ | ❌ | ❌ | ❌ | Simplex algorithm (derivative-free) |
| `"CG"` | ❌ | ❌ | ✅ | ❌ | Conjugate gradient |
| `"BFGS"` | ❌ | ❌ | ✅ | ❌ | Broyden-Fletcher-Goldfarb-Shanno |
| `"Newton-CG"` | ❌ | ❌ | ✅ | ✅ | Newton conjugate gradient |
| `"dogleg"` | ❌ | ❌ | ✅ | ✅ | Dog-leg trust-region |
| `"trust-ncg"` | ❌ | ❌ | ✅ | ✅ | Newton conjugate gradient trust-region |
| `"trust-exact"` | ❌ | ❌ | ✅ | ✅ | Nearly exact trust-region |
| `"trust-krylov"` | ❌ | ❌ | ✅ | ✅ | Krylov subspace trust-region |

::: {.callout-tip}
## Recommended Methods
- **With constraints**: Use `"SLSQP"` (default) or `"trust-constr"`
- **Bounds only**: Use `"L-BFGS-B"` for large-scale problems
- **Unconstrained**: Use `"BFGS"` or `"trust-ncg"` for smooth problems
:::

---

## Strict Mode

Use `strict=True` to enforce that the solver can handle all problem features exactly:

```python
# Default: warn and relax integer/binary to continuous
solution = prob.solve()  # Works, but may produce fractional values

# Strict: fail if problem can't be solved exactly
solution = prob.solve(strict=True)  # Raises ValueError for integer/binary
```

This is useful for production code where you want to ensure correctness:

- **Prototyping:** Use `strict=False` (default) to quickly test ideas
- **Production:** Use `strict=True` to catch unsupported configurations early

---

## Properties

| Property | Type | Description |
|----------|------|-------------|
| `.name` | `str | None` | Problem name |
| `.objective` | `Expression` | Objective function |
| `.sense` | `str` | `"minimize"` or `"maximize"` |
| `.constraints` | `list[Constraint]` | All constraints |
| `.variables` | `list[Variable]` | All decision variables |

### Examples

```{python}
from optyx import Variable, Problem

x = Variable("x", lb=0)
y = Variable("y", lb=0)

prob = (
    Problem("demo")
    .minimize(x**2 + y**2)
    .subject_to(x + y >= 1)
)

print(f"Name: {prob.name}")
print(f"Sense: {prob.sense}")
print(f"Variables: {[v.name for v in prob.variables]}")
print(f"Num constraints: {len(prob.constraints)}")
```

---

## Complete Example

```{python}
from optyx import Variable, Problem, exp

# Portfolio with 3 assets
w1 = Variable("stocks", lb=0, ub=0.6)
w2 = Variable("bonds", lb=0, ub=0.5)
w3 = Variable("cash", lb=0.1, ub=1.0)

# Expected returns
returns = 0.08*w1 + 0.04*w2 + 0.02*w3

# Risk (simplified variance)
risk = 0.04*w1**2 + 0.01*w2**2 + 0.001*w3**2

# Build and solve
solution = (
    Problem("portfolio")
    .minimize(risk)
    .subject_to(w1 + w2 + w3 >= 0.99)  # Fully invested
    .subject_to(w1 + w2 + w3 <= 1.01)
    .subject_to(returns >= 0.05)        # Min 5% return
    .solve()
)

print("Optimal Allocation:")
print(f"  Stocks: {solution['stocks']:.1%}")
print(f"  Bonds:  {solution['bonds']:.1%}")
print(f"  Cash:   {solution['cash']:.1%}")
print(f"Risk: {solution.objective_value:.6f}")
```
